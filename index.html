/**
 * LeakRadar â€” GLOBAL DevOps Leak Bot
 * Telegram + Cloudflare Worker + KV + Shodan + GLOBAL Dashboard
 * Defensive auditing only.
 */

const SHODAN_CACHE_TTL = 60 * 60 * 12;
const BULK_LIMIT_PER_RUN = 6;
const BULK_MAX_TARGETS = 200;
const LEAK_CACHE_TTL = 60 * 30;

const GLOBAL_ID = "global";
const GLOBAL_RESULTS_LIMIT = 1200;
const GLOBAL_ACTIVITY_LIMIT = 2000;

// Sensitive endpoints (defensive only)
const SENSITIVE_PATHS_MVP = [
  "/admin","/admin/login","/login","/wp-admin","/phpmyadmin",
  "/.well-known/security.txt","/server-status"
];
const SENSITIVE_PROBE_TIMEOUT_MS = 5500;

export default {
  async fetch(req, env, ctx) {
    const url = new URL(req.url);

    if (req.method === "OPTIONS") return new Response("", { headers: corsHeaders() });

    // Telegram webhook
    if (url.pathname === "/telegram" && req.method === "POST") {
      const update = await req.json().catch(()=>null);
      if(update) ctx.waitUntil(handleTelegram(update, env, ctx, req));
      return new Response("ok", { headers: corsHeaders() });
    }

    // Internal bulk runner
    if (url.pathname === "/internal/run") {
      return internalAuth(req, env, async ()=>{
        const chatId = url.searchParams.get("chatId");
        if(!chatId) return json({ok:false,error:"missing chatId"},400);
        const r = await runBulkSlice(chatId, env, ctx, req);
        return json({ok:true,...r});
      });
    }

    // ===== GLOBAL APIs =====

    if (url.pathname === "/api/global/results") {
      return apiAuth(req, env, async ()=>{
        const limit = Math.min(500, parseInt(url.searchParams.get("limit")||"200",10));
        const arr = await env.KV.get(`global:result:${GLOBAL_ID}`,"json") || [];
        return json({ok:true, results: arr.slice(0,limit)});
      });
    }

    if (url.pathname === "/api/global/activity") {
      return apiAuth(req, env, async ()=>{
        const limit = Math.min(500, parseInt(url.searchParams.get("limit")||"200",10));
        const arr = await env.KV.get(`global:act:${GLOBAL_ID}`,"json") || [];
        return json({ok:true, activity: arr.slice(0,limit)});
      });
    }

    if (url.pathname === "/api/global/stats") {
      return apiAuth(req, env, async ()=>{
        const s = await env.KV.get(`global:stats:${GLOBAL_ID}`,"json") || null;
        return json({ok:true, stats:s});
      });
    }

    if (url.pathname === "/api/global/export.csv") {
      return apiAuth(req, env, async ()=>{
        const arr = await env.KV.get(`global:result:${GLOBAL_ID}`,"json") || [];
        return new Response(toCSV(arr), {
          status:200,
          headers:{...corsHeaders(),"content-type":"text/csv; charset=utf-8"}
        });
      });
    }

    return new Response("LeakRadar GLOBAL OK");
  }
};

// ================= Telegram =================

async function handleTelegram(update, env, ctx, req){
  try{
    const msg = update.message;
    if(!msg || !msg.text) return;

    const chatId = msg.chat?.id;
    const text = msg.text.trim();

    const userLabel = tgUserLabel(msg);
    const chatLabel = tgChatLabel(msg);

    if(text==="/start" || text==="/help"){
      await sendTG(env, chatId,
`LeakRadar GLOBAL

/scan domain.com
/bulk list
/status
/export`);
      return;
    }

    if(text.startsWith("/scan")){
      const raw = text.replace("/scan","").trim();
      if(!raw) return sendTG(env,chatId,"/scan example.com");

      const domain = normalizeTarget(raw).host;

      await globalLogActivity(env,{type:"cmd",cmd:"scan",target:domain,user:userLabel,chat:chatLabel,chatId});

      const res = await auditDomain(domain, env);

      await globalUpdateStats(env,res);
      await globalAppendResult(env,res,{user:userLabel,chat:chatLabel,chatId,source:"scan"});
      await globalLogActivity(env,{type:"result",domain:res.domain,risk:res.risk,leaks:(res.leaks||[]).length,user:userLabel,chat:chatLabel,chatId});

      return sendTG(env, chatId, formatSingleReport(res,false));
    }

    if(text.startsWith("/bulk")){
      const list = text.replace("/bulk","").trim();
      const targets = parseTargets(list).slice(0,BULK_MAX_TARGETS);
      if(!targets.length) return sendTG(env,chatId,"/bulk domain1\ndomain2");

      await globalLogActivity(env,{type:"cmd",cmd:"bulk",count:targets.length,user:userLabel,chat:chatLabel,chatId});

      await env.KV.put(`bulk:queue:${chatId}`, JSON.stringify(targets));
      await env.KV.put(`bulk:progress:${chatId}`, JSON.stringify({total:targets.length,done:0,startedAt:Date.now()}));
      await env.KV.put(`bulk:result:${chatId}`, JSON.stringify([]));

      await sendTG(env,chatId,`Received ${targets.length} targets`);
      ctx.waitUntil(kickRunner(chatId, env, req));
      return;
    }

    if(text==="/status"){
      const p = await env.KV.get(`bulk:progress:${chatId}`,"json");
      if(!p) return sendTG(env,chatId,"No batch");
      return sendTG(env,chatId,`${p.done}/${p.total}`);
    }

    if(text==="/export"){
      const r = await env.KV.get(`bulk:result:${chatId}`,"json")||[];
      return sendTG(env,chatId,toCSV(r).slice(0,3500));
    }

  }catch(e){
    console.log("telegram error",e);
  }
}

// ================= Bulk =================

async function kickRunner(chatId, env, req){
  const u = new URL(req.url);
  const base = `${u.protocol}//${u.host}`;
  await fetch(`${base}/internal/run?chatId=${chatId}`,{
    headers:{authorization:`Bearer ${env.RUN_TOKEN}`}
  });
}

async function runBulkSlice(chatId, env, ctx, req){
  let queue = await env.KV.get(`bulk:queue:${chatId}`,"json")||[];
  if(!queue.length) return {done:true};

  let prog = await env.KV.get(`bulk:progress:${chatId}`,"json");

  const slice = queue.splice(0,BULK_LIMIT_PER_RUN);
  await env.KV.put(`bulk:queue:${chatId}`,JSON.stringify(queue));

  for(const t of slice){
    const domain = normalizeTarget(t).host;
    const res = await auditDomain(domain, env);

    const arr = await env.KV.get(`bulk:result:${chatId}`,"json")||[];
    arr.push(res);
    await env.KV.put(`bulk:result:${chatId}`,JSON.stringify(arr));

    prog.done++;
    await env.KV.put(`bulk:progress:${chatId}`,JSON.stringify(prog));

    // GLOBAL
    await globalUpdateStats(env,res);
    await globalAppendResult(env,res,{user:"bulk",chat:String(chatId),chatId,source:"bulk"});
    await globalLogActivity(env,{type:"result",domain:res.domain,risk:res.risk,leaks:(res.leaks||[]).length,user:"bulk",chat:String(chatId),chatId});
  }

  if(queue.length){
    ctx.waitUntil(kickRunner(chatId,env,req));
    return {done:false};
  }

  return {done:true};
}

// ================= Audit =================

async function auditDomain(domain, env){
  const resolvedIp = isIPv4(domain)?domain:await resolveA(domain);
  const shodanRaw = resolvedIp?await shodanHost(resolvedIp,env):null;
  const shodan = shodanRaw?sanitizeShodan(shodanRaw):null;

  const ports = shodan?.ports||[];
  const shouldWeb = ports.some(p=>[80,443,8080,8443].includes(p));
  const leaks = shouldWeb?await scanLeaksForDomain(domain):[];
  const sens = shouldWeb?await scanSensitivePathsForDomain(domain):[];

  const risk = scoreRisk(leaks, shodan, sens);
  return {ts:Date.now(),domain,resolvedIp,risk,leaks,sensitivePaths:sens,shodan};
}

function scoreRisk(leaks, shodan, sens){
  let max = 0;
  for(const f of leaks||[]) if(f.sev==="CRITICAL") max=3;
  if(max<3){
    const ports = shodan?.ports||[];
    if([2375,6379,9200].some(p=>ports.includes(p))) max=3;
  }
  if(max===0 && sens?.length) max=1;
  return max===3?"CRITICAL":max===2?"HIGH":max===1?"MEDIUM":"OK";
}

// ================= GLOBAL store =================

async function globalAppendResult(env,res,meta){
  const k=`global:result:${GLOBAL_ID}`;
  const a=await env.KV.get(k,"json")||[];
  a.unshift({...res,meta:{...meta,at:Date.now()}});
  if(a.length>GLOBAL_RESULTS_LIMIT)a.length=GLOBAL_RESULTS_LIMIT;
  await env.KV.put(k,JSON.stringify(a));
}

async function globalLogActivity(env,e){
  const k=`global:act:${GLOBAL_ID}`;
  const a=await env.KV.get(k,"json")||[];
  a.unshift({ts:Date.now(),...e});
  if(a.length>GLOBAL_ACTIVITY_LIMIT)a.length=GLOBAL_ACTIVITY_LIMIT;
  await env.KV.put(k,JSON.stringify(a));
}

async function globalUpdateStats(env,res){
  const k=`global:stats:${GLOBAL_ID}`;
  const s=await env.KV.get(k,"json")||{totalScans:0,riskCount:{CRITICAL:0,HIGH:0,MEDIUM:0,OK:0},topTargets:{},topLeaks:{},last30:[]};
  s.totalScans++;
  s.riskCount[res.risk]=(s.riskCount[res.risk]||0)+1;
  s.topTargets[res.domain]=(s.topTargets[res.domain]||0)+1;
  for(const f of res.leaks||[]){
    const kk=`${f.sev}:${f.path}`;
    s.topLeaks[kk]=(s.topLeaks[kk]||0)+1;
  }
  const d=new Date().toISOString().slice(0,10);
  let row=s.last30.find(x=>x.day===d);
  if(!row){row={day:d,scans:0,critical:0};s.last30.unshift(row);}
  row.scans++; if(res.risk==="CRITICAL")row.critical++;
  if(s.last30.length>30)s.last30.length=30;
  await env.KV.put(k,JSON.stringify(s));
}

// ================= Helpers =================

function corsHeaders(){
  return {
    "Access-Control-Allow-Origin":"*",
    "Access-Control-Allow-Methods":"GET,POST,OPTIONS",
    "Access-Control-Allow-Headers":"content-type,authorization"
  };
}

function json(d,s=200){
  return new Response(JSON.stringify(d),{status:s,headers:{...corsHeaders(),"content-type":"application/json"}});
}

async function apiAuth(req,env,fn){
  const a=req.headers.get("authorization")||"";
  if(a!==`Bearer ${env.DASHBOARD_TOKEN}`) return json({ok:false,error:"unauthorized"},401);
  return fn();
}

async function internalAuth(req,env,fn){
  const a=req.headers.get("authorization")||"";
  if(a!==`Bearer ${env.RUN_TOKEN}`) return json({ok:false,error:"unauthorized"},401);
  return fn();
}

function parseTargets(s){return s.split(/[\n,]+/).map(x=>x.trim()).filter(Boolean);}
function normalizeTarget(i){let s=i.trim();if(!/^https?:\/\//.test(s))s="https://"+s;const u=new URL(s);return{host:u.hostname};}
function isIPv4(s){return /^(\d+\.){3}\d+$/.test(s);}

function tgUserLabel(msg){
  const u=msg.from||{};
  return u.username?`@${u.username}`:[u.first_name,u.last_name].filter(Boolean).join(" ")||"user";
}
function tgChatLabel(msg){
  return msg.chat?.title||msg.chat?.type||"chat";
}

async function sendTG(env,chatId,text){
  try{
    await fetch(`https://api.telegram.org/bot${env.TELEGRAM_BOT_TOKEN}/sendMessage`,{
      method:"POST",
      headers:{"content-type":"application/json"},
      body:JSON.stringify({chat_id:chatId,text,disable_web_page_preview:true})
    });
  }catch(e){console.log("sendTG",e);}
}

// ================= Leak probes =================

async function scanLeaksForDomain(domain){
  const bases=[`https://${domain}`,`http://${domain}`];
  const paths=[
    {p:"/.env",sev:"CRITICAL",sig:/DB_|APP_/},
    {p:"/.git/HEAD",sev:"CRITICAL",sig:/ref:/},
    {p:"/phpinfo.php",sev:"HIGH",sig:/phpinfo/}
  ];
  const f=[];
  for(const it of paths){
    for(const b of bases){
      try{
        const r=await fetch(b+it.p,{method:"GET"});
        if(r.status===200){
          const t=await r.text();
          if(it.sig.test(t)) f.push({sev:it.sev,path:it.p});
        }
      }catch{}
    }
  }
  return f;
}

async function scanSensitivePathsForDomain(domain){
  const bases=[`https://${domain}`,`http://${domain}`];
  const f=[];
  for(const p of SENSITIVE_PATHS_MVP){
    for(const b of bases){
      try{
        const r=await fetch(b+p,{method:"GET"});
        if([200,401,403].includes(r.status)) f.push({path:p,status:r.status});
      }catch{}
    }
  }
  return f;
}

// ================= Shodan =================

async function shodanHost(ip,env){
  const k=`shodan:${ip}`;
  const c=await env.KV.get(k,"json");
  if(c)return c;
  const r=await fetch(`https://api.shodan.io/shodan/host/${ip}?key=${env.SHODAN_API_KEY}`);
  const j=await r.json();
  await env.KV.put(k,JSON.stringify(j),{expirationTtl:SHODAN_CACHE_TTL});
  return j;
}

function sanitizeShodan(j){
  return {
    ports:j.ports||[],
    org:j.org||"",
    asn:j.asn||"",
    country:j.country_name||""
  };
}

// ================= DNS =================

async function resolveA(d){
  try{
    const r=await fetch(`https://cloudflare-dns.com/dns-query?name=${d}&type=A`,{headers:{accept:"application/dns-json"}});
    const j=await r.json();
    const a=j.Answer?.find(x=>x.type===1);
    return a?.data||null;
  }catch{return null;}
}

// ================= CSV =================

function toCSV(arr){
  const rows=[["domain","ip","risk","user","chat"]];
  for(const r of arr){
    rows.push([
      r.domain,
      r.resolvedIp||"",
      r.risk,
      r.meta?.user||"",
      r.meta?.chat||""
    ]);
  }
  return rows.map(x=>x.map(s=>`"${String(s).replace(/"/g,'""')}"`).join(",")).join("\n");
}
